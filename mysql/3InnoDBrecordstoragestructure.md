<h2>InnoDB记录存储结构</h2>

<h5>InnoDB页介绍<h5>
InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

<h5>InnoDB行格式</h5>
我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。设计InnoDB存储引擎的大叔们到现在为止设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

<h5>compact行格式</h5>

![compact行格式](https://tianxinmao.oss-cn-hangzhou.aliyuncs.com/study/169710e8fafc21aa.jpg)

从上图可知，一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分，下边我们详细看一下这两部分的组成

<h6>记录的额外信息</h6>
这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是变长字段长度列表、NULL值列表和记录头信息，我们分别看一下。

<h6>变长字段长度列表</h6>
我们知道MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型，我们也可以把拥有这些数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把MySQL服务器搞懵，所以这些变长字段占用的存储空间分为两部分：
 * 真正的数据内容
 + 占用的字节数
在compact行格式中，把所有变长字段的真实数据占用的字节长度都存在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序排序。（逆序）
变长字段长度列表的字节串用十六进制表示的效果
具体用1个还是2个字节来表示真实数据占用的字节数
具体用1个还是2个字节来表示真实数据占用的字节数，InnoDB有它的一套规则，我们先声明一下W、M和L的意思：
 + 假设某个字符集中表示一个字符最多需要使用字节数为W，也就是舒勇SHOW CHARSET中的Maxlen列，比如说utf8中的w就是3，gbk字符集中的W就是2，ascii的字符集中的W为1
 + 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多M个字符（注意字符不是字节），所以这个类型能表示的字符串的最多占用字节数就是MxM。
 + 假设它实际存储的字符串占用字节数是L
所以确定是使用1个字节还是2个字节表示真正字符串所占用的字节数的规则就是这样：
 + 如果MxW<=255，那么使用一个字节来表示真正字符串真用的字节数
 + 如果MxW>255,则分为2种情况:
    + 如果L<=127,则用1个字节来表示真正字符串占用的字节数
    + 如果L>127,则用2个字节来表示真正字符串占用的字节数
    
<h5>总结一下</h5>
总结一下就是说：如果该可变字段允许存储的最大字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节。
```
需要注意的点：
    变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的 
```

<h5>NULL值列表</h5>
外面知道表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以compact行格式把这些值为null的列统一管理起来，存储到NUll值列表中，它的处理过程是这样的：
 + 首先统计表中允许存储NULL的列有哪些
   外面前边说过，主键列、被NOT NULL休息的列都是不可以存储NULL值的，所以在统计的时候不会把这些列算进去
 + 如果表中没有允许存储null的列，则null值列表也不存在了，否则将每个允许存储为null的列对应一个二进制位，二进制位按照猎德的顺序逆序排列，二进制位表示的意义如下：
    + 二进制位的值为1时，代表该列的值为NULL
    + 二进制位的值为0时，代表该列的值部位NULL 
 + mysql规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。
 
 第一条记录，C1,C3,C4的3个列的值都不为NULL，所以他们对应的二进制位都是0
 00000000 十六进制 0x00
 第二条记录，C1,C3,C4的3个列中C3和C4值都为null，所以这三列对应的二进制位情况就是：
 00000110 十六进制 0x06
 
 ![null值列表](https://tianxinmao.oss-cn-hangzhou.aliyuncs.com/study/WX20200716-113535%402x.png)
 
 <h5>记录头信息</h5>
 除了 变长字段长度列表，null值列表之外，海鸥一个用于描述记录的 记录头信息，它是由固定的5个字节组成，5个字节就是40个二进制位，不同的为表示不同的信息，如图：
 
 ![记录头信息](https://tianxinmao.oss-cn-hangzhou.aliyuncs.com/study/WX20200716-135249.png)
 
![前面2行记录的记录头信息](https://tianxinmao.oss-cn-hangzhou.aliyuncs.com/study/WX20200716-144308%402x.png)

<h5>记录的真实数据<h5>
记录的真实数据除了我们自己定义的列的数据以外，MySQL会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：

|列名|是否必须|占用空间|描述|
|---|---|---|---|
|db_row_id|否|6字节|行id,唯一表示一条记录|
|db_trx_id|是|6字节|事务id|
|db_roll_ptr|是|7字节|回滚指针|

这里需要提一下 InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）

变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)却没有这个要求。比方说对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计Compact行格式的大叔既想节省存储空间，又不想更新CHAR(M)类型的列产生碎片时的纠结心情了吧。）